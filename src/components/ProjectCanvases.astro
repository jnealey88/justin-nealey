---
---

<script>
  // ─── Airo Canvas — Agent Network ────────────────
  const airoCanvas = document.getElementById('airo-canvas') as HTMLCanvasElement | null;
  if (airoCanvas) {
    const actx = airoCanvas.getContext('2d')!;

    function resizeAiroCanvas() {
      const rect = airoCanvas!.parentElement!.getBoundingClientRect();
      airoCanvas!.width = rect.width || 400;
      airoCanvas!.height = rect.height || 320;
    }
    resizeAiroCanvas();
    window.addEventListener('resize', resizeAiroCanvas);

    const agents = [
      { label: 'AIRO', radius: 16, orbit: 0, speed: 0, angle: 0 },
      { label: 'Design', radius: 8, orbit: 80, speed: 0.4, angle: 0 },
      { label: 'Content', radius: 8, orbit: 80, speed: 0.4, angle: Math.PI * 0.667 },
      { label: 'Build', radius: 8, orbit: 80, speed: 0.4, angle: Math.PI * 1.333 },
      { label: 'SEO', radius: 6, orbit: 120, speed: -0.25, angle: Math.PI * 0.25 },
      { label: 'Images', radius: 6, orbit: 120, speed: -0.25, angle: Math.PI * 0.75 },
      { label: 'Theme', radius: 6, orbit: 120, speed: -0.25, angle: Math.PI * 1.25 },
      { label: 'Copy', radius: 6, orbit: 120, speed: -0.25, angle: Math.PI * 1.75 },
    ];

    function drawAiroNetwork() {
      const w = airoCanvas!.width;
      const h = airoCanvas!.height;
      const t = Date.now() * 0.001;
      const cx = w / 2;
      const cy = h / 2;

      actx.clearRect(0, 0, w, h);

      const positions = agents.map((agent) => {
        if (agent.orbit === 0) return { x: cx, y: cy, ...agent };
        const a = agent.angle + t * agent.speed;
        return { x: cx + Math.cos(a) * agent.orbit, y: cy + Math.sin(a) * agent.orbit, ...agent };
      });

      positions.forEach((pos, i) => {
        if (i === 0) return;
        const pulse = 0.15 + Math.sin(t * 2 + i) * 0.1;
        actx.beginPath();
        actx.moveTo(positions[0].x, positions[0].y);
        actx.lineTo(pos.x, pos.y);
        actx.strokeStyle = `rgba(0, 212, 255, ${pulse})`;
        actx.lineWidth = 1;
        actx.stroke();

        const packetT = (Math.sin(t * 1.5 + i * 0.8) + 1) / 2;
        const px = positions[0].x + (pos.x - positions[0].x) * packetT;
        const py = positions[0].y + (pos.y - positions[0].y) * packetT;
        actx.beginPath();
        actx.arc(px, py, 2, 0, Math.PI * 2);
        actx.fillStyle = `rgba(123, 97, 255, ${0.6 + Math.sin(t * 3 + i) * 0.3})`;
        actx.fill();
      });

      [80, 120].forEach((r) => {
        actx.beginPath();
        actx.arc(cx, cy, r, 0, Math.PI * 2);
        actx.strokeStyle = 'rgba(0, 212, 255, 0.06)';
        actx.lineWidth = 1;
        actx.stroke();
      });

      positions.forEach((pos, i) => {
        const glow = actx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, pos.radius * 3);
        if (i === 0) {
          glow.addColorStop(0, 'rgba(0, 212, 255, 0.3)');
          glow.addColorStop(1, 'rgba(0, 212, 255, 0)');
        } else {
          glow.addColorStop(0, 'rgba(123, 97, 255, 0.2)');
          glow.addColorStop(1, 'rgba(123, 97, 255, 0)');
        }
        actx.beginPath();
        actx.arc(pos.x, pos.y, pos.radius * 3, 0, Math.PI * 2);
        actx.fillStyle = glow;
        actx.fill();

        actx.beginPath();
        actx.arc(pos.x, pos.y, pos.radius, 0, Math.PI * 2);
        if (i === 0) {
          actx.fillStyle = 'rgba(0, 212, 255, 0.8)';
          actx.shadowColor = '#00d4ff';
          actx.shadowBlur = 20;
        } else {
          const brightness = 0.4 + Math.sin(t * 2 + i * 0.7) * 0.2;
          actx.fillStyle = `rgba(123, 97, 255, ${brightness})`;
          actx.shadowColor = '#7b61ff';
          actx.shadowBlur = 10;
        }
        actx.fill();
        actx.shadowBlur = 0;
      });

      requestAnimationFrame(drawAiroNetwork);
    }
    drawAiroNetwork();
  }

  // ─── MRR Canvas — Market Research Report ──────────
  const mrrCanvas = document.getElementById('mrr-canvas') as HTMLCanvasElement | null;
  if (mrrCanvas) {
    const mctx = mrrCanvas.getContext('2d')!;

    function resizeMrrCanvas() {
      const rect = mrrCanvas!.parentElement!.getBoundingClientRect();
      mrrCanvas!.width = rect.width || 400;
      mrrCanvas!.height = rect.height || 320;
    }
    resizeMrrCanvas();
    window.addEventListener('resize', resizeMrrCanvas);

    function drawMrr() {
      const w = mrrCanvas!.width;
      const h = mrrCanvas!.height;
      const t = Date.now() * 0.001;

      mctx.clearRect(0, 0, w, h);

      const lineCount = 8;
      const lineStartX = w * 0.15;
      const lineEndX = w * 0.85;
      const lineStartY = h * 0.12;
      const lineSpacing = h * 0.065;

      for (let i = 0; i < lineCount; i++) {
        const y = lineStartY + i * lineSpacing;
        const progress = Math.min(1, Math.max(0, (Math.sin(t * 0.8 - i * 0.3) + 1) / 2));
        const endX = lineStartX + (lineEndX - lineStartX) * (0.5 + progress * 0.5);
        const alpha = 0.15 + progress * 0.2;

        mctx.beginPath();
        mctx.moveTo(lineStartX, y);
        mctx.lineTo(endX, y);
        mctx.strokeStyle = `rgba(0, 212, 255, ${alpha})`;
        mctx.lineWidth = 2;
        mctx.stroke();
      }

      const glassX = w * 0.5 + Math.sin(t * 0.6) * w * 0.2;
      const glassY = h * 0.35 + Math.cos(t * 0.4) * h * 0.1;
      const glassR = 18;

      const glow = mctx.createRadialGradient(glassX, glassY, 0, glassX, glassY, glassR * 3);
      glow.addColorStop(0, 'rgba(123, 97, 255, 0.2)');
      glow.addColorStop(1, 'rgba(123, 97, 255, 0)');
      mctx.beginPath();
      mctx.arc(glassX, glassY, glassR * 3, 0, Math.PI * 2);
      mctx.fillStyle = glow;
      mctx.fill();

      mctx.beginPath();
      mctx.arc(glassX, glassY, glassR, 0, Math.PI * 2);
      mctx.strokeStyle = 'rgba(123, 97, 255, 0.6)';
      mctx.lineWidth = 2;
      mctx.stroke();

      const handleAngle = Math.PI * 0.25;
      mctx.beginPath();
      mctx.moveTo(glassX + Math.cos(handleAngle) * glassR, glassY + Math.sin(handleAngle) * glassR);
      mctx.lineTo(glassX + Math.cos(handleAngle) * (glassR + 12), glassY + Math.sin(handleAngle) * (glassR + 12));
      mctx.strokeStyle = 'rgba(123, 97, 255, 0.5)';
      mctx.lineWidth = 3;
      mctx.stroke();

      const insights = [
        { x: w * 0.25, y: h * 0.72, color: '#00d4ff', label: 'Industry' },
        { x: w * 0.5, y: h * 0.72, color: '#7b61ff', label: 'Company' },
        { x: w * 0.75, y: h * 0.72, color: '#00ff88', label: 'Insights' },
      ];

      insights.forEach((node, i) => {
        const breathe = 1 + Math.sin(t * 1.5 + i * 1.2) * 0.15;
        const r = 8 * breathe;
        const hex = node.color;
        const cr = parseInt(hex.slice(1, 3), 16);
        const cg = parseInt(hex.slice(3, 5), 16);
        const cb = parseInt(hex.slice(5, 7), 16);

        const pulse = 0.1 + Math.sin(t * 2 + i) * 0.08;
        mctx.beginPath();
        mctx.moveTo(node.x, h * 0.55);
        mctx.lineTo(node.x, node.y);
        mctx.strokeStyle = `rgba(${cr}, ${cg}, ${cb}, ${pulse})`;
        mctx.lineWidth = 1;
        mctx.stroke();

        const nodeGlow = mctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, r * 3);
        nodeGlow.addColorStop(0, `rgba(${cr}, ${cg}, ${cb}, 0.25)`);
        nodeGlow.addColorStop(1, `rgba(${cr}, ${cg}, ${cb}, 0)`);
        mctx.beginPath();
        mctx.arc(node.x, node.y, r * 3, 0, Math.PI * 2);
        mctx.fillStyle = nodeGlow;
        mctx.fill();

        mctx.beginPath();
        mctx.arc(node.x, node.y, r, 0, Math.PI * 2);
        mctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, 0.6)`;
        mctx.shadowColor = node.color;
        mctx.shadowBlur = 10;
        mctx.fill();
        mctx.shadowBlur = 0;
      });

      for (let i = 0; i < 3; i++) {
        const packetT = ((t * 0.7 + i * 0.7) % 2) / 2;
        if (packetT <= 1) {
          const fromY = glassY + glassR;
          const toNode = insights[i];
          const px = glassX + (toNode.x - glassX) * packetT;
          const py = fromY + (toNode.y - fromY) * packetT;
          mctx.beginPath();
          mctx.arc(px, py, 2, 0, Math.PI * 2);
          mctx.fillStyle = `rgba(0, 212, 255, ${0.5 + Math.sin(t * 3 + i) * 0.3})`;
          mctx.fill();
        }
      }

      requestAnimationFrame(drawMrr);
    }
    drawMrr();
  }

  // ─── RPG Canvas — Stat Bars & XP ─────────────────
  const rpgCanvas = document.getElementById('rpg-canvas') as HTMLCanvasElement | null;
  if (rpgCanvas) {
    const rctx = rpgCanvas.getContext('2d')!;

    function resizeRpgCanvas() {
      const rect = rpgCanvas!.parentElement!.getBoundingClientRect();
      rpgCanvas!.width = rect.width || 400;
      rpgCanvas!.height = rect.height || 320;
    }
    resizeRpgCanvas();
    window.addEventListener('resize', resizeRpgCanvas);

    const stats = [
      { label: 'STR', color: '#ff4d4d' },
      { label: 'WIS', color: '#7b61ff' },
      { label: 'CHA', color: '#00d4ff' },
      { label: 'STA', color: '#00ff88' },
      { label: 'AGI', color: '#ffaa00' },
      { label: 'INT', color: '#ff61d4' },
    ];

    function drawRpg() {
      const w = rpgCanvas!.width;
      const h = rpgCanvas!.height;
      const t = Date.now() * 0.001;

      rctx.clearRect(0, 0, w, h);

      const barWidth = w * 0.5;
      const barHeight = 8;
      const startX = (w - barWidth) / 2;
      const startY = h * 0.2;
      const gap = 28;

      stats.forEach((stat, i) => {
        const y = startY + i * gap;
        const fillPercent = 0.4 + Math.sin(t * 0.8 + i * 1.1) * 0.3;

        rctx.font = '10px "Space Mono", monospace';
        rctx.fillStyle = 'rgba(232, 232, 239, 0.5)';
        rctx.textAlign = 'right';
        rctx.fillText(stat.label, startX - 10, y + 7);

        rctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        rctx.fillRect(startX, y, barWidth, barHeight);

        rctx.fillStyle = stat.color;
        rctx.globalAlpha = 0.6 + Math.sin(t * 2 + i) * 0.2;
        rctx.fillRect(startX, y, barWidth * fillPercent, barHeight);
        rctx.globalAlpha = 1;

        const tipX = startX + barWidth * fillPercent;
        const glw = rctx.createRadialGradient(tipX, y + barHeight / 2, 0, tipX, y + barHeight / 2, 15);
        glw.addColorStop(0, stat.color.replace(')', ', 0.3)').replace('rgb', 'rgba'));
        glw.addColorStop(1, 'rgba(0,0,0,0)');
        rctx.fillStyle = glw;
        rctx.fillRect(tipX - 15, y - 10, 30, barHeight + 20);
      });

      const xpY = startY + stats.length * gap + 15;
      const xpFill = (Math.sin(t * 0.3) + 1) / 2;
      rctx.font = '10px "Space Mono", monospace';
      rctx.fillStyle = 'rgba(0, 212, 255, 0.5)';
      rctx.textAlign = 'center';
      rctx.fillText('LVL ' + Math.floor(5 + Math.sin(t * 0.1) * 2), w / 2, xpY - 5);

      rctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      rctx.fillRect(startX, xpY, barWidth, 6);
      rctx.fillStyle = 'rgba(0, 212, 255, 0.5)';
      rctx.fillRect(startX, xpY, barWidth * xpFill, 6);

      requestAnimationFrame(drawRpg);
    }
    drawRpg();
  }

  // ─── Obsidian Canvas — Terminal/Chat ──────────────
  const obsidianCanvas = document.getElementById('obsidian-canvas') as HTMLCanvasElement | null;
  if (obsidianCanvas) {
    const octx = obsidianCanvas.getContext('2d')!;

    function resizeObsidianCanvas() {
      const rect = obsidianCanvas!.parentElement!.getBoundingClientRect();
      obsidianCanvas!.width = rect.width || 400;
      obsidianCanvas!.height = rect.height || 320;
    }
    resizeObsidianCanvas();
    window.addEventListener('resize', resizeObsidianCanvas);

    const lines = [
      { prefix: '>', text: 'Summarize my meeting notes', color: '#e8e8ef' },
      { prefix: '', text: 'Reading vault/meetings/2026-02...', color: '#7b61ff' },
      { prefix: '', text: 'Found 3 files. Summarizing...', color: '#7b61ff' },
      { prefix: '>', text: 'Create action items from summary', color: '#e8e8ef' },
      { prefix: '', text: 'Writing vault/tasks/actions.md', color: '#00d4ff' },
      { prefix: '', text: 'Done. Created 5 action items.', color: '#00ff88' },
    ];

    function drawObsidian() {
      const w = obsidianCanvas!.width;
      const h = obsidianCanvas!.height;
      const t = Date.now() * 0.001;

      octx.clearRect(0, 0, w, h);

      const lineHeight = 22;
      const startX = w * 0.1;
      const startY = h * 0.18;
      const totalCycleTime = lines.length * 1.5 + 2;
      const cycleT = t % totalCycleTime;

      lines.forEach((line, i) => {
        const lineAppearTime = i * 1.5;
        if (cycleT < lineAppearTime) return;

        const elapsed = cycleT - lineAppearTime;
        const fullText = (line.prefix ? line.prefix + ' ' : '') + line.text;
        const charsToShow = Math.min(Math.floor(elapsed * 20), fullText.length);
        const displayText = fullText.substring(0, charsToShow);

        const y = startY + i * lineHeight;
        const alpha = Math.min(elapsed * 2, 0.8);

        const hex = line.color;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        octx.font = '11px "Space Mono", monospace';
        octx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        octx.textAlign = 'left';
        octx.fillText(displayText, startX, y);

        if (charsToShow < fullText.length && Math.sin(t * 6) > 0) {
          const textWidth = octx.measureText(displayText).width;
          octx.fillStyle = `rgba(0, 212, 255, ${alpha})`;
          octx.fillRect(startX + textWidth + 2, y - 10, 7, 13);
        }
      });

      requestAnimationFrame(drawObsidian);
    }
    drawObsidian();
  }

  // ─── Vantalyze Canvas — Opportunity Solution Tree ─
  const vantalyzeCanvas = document.getElementById('vantalyze-canvas') as HTMLCanvasElement | null;
  if (vantalyzeCanvas) {
    const vtctx = vantalyzeCanvas.getContext('2d')!;

    function resizeVantalyzeCanvas() {
      const rect = vantalyzeCanvas!.parentElement!.getBoundingClientRect();
      vantalyzeCanvas!.width = rect.width || 400;
      vantalyzeCanvas!.height = rect.height || 320;
    }
    resizeVantalyzeCanvas();
    window.addEventListener('resize', resizeVantalyzeCanvas);

    function drawVantalyze() {
      const w = vantalyzeCanvas!.width;
      const h = vantalyzeCanvas!.height;
      const t = Date.now() * 0.001;

      vtctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const levels = [
        [{ x: cx, y: h * 0.15, r: 12, color: '#00d4ff', label: 'Outcome' }],
        [
          { x: cx - 70, y: h * 0.42, r: 9, color: '#7b61ff', label: 'Opp 1' },
          { x: cx + 70, y: h * 0.42, r: 9, color: '#7b61ff', label: 'Opp 2' },
        ],
        [
          { x: cx - 105, y: h * 0.72, r: 7, color: '#00ff88', label: 'S1' },
          { x: cx - 35, y: h * 0.72, r: 7, color: '#00ff88', label: 'S2' },
          { x: cx + 35, y: h * 0.72, r: 7, color: '#00ff88', label: 'S3' },
          { x: cx + 105, y: h * 0.72, r: 7, color: '#00ff88', label: 'S4' },
        ],
      ];

      vtctx.lineWidth = 1;
      levels[1].forEach((node) => {
        const pulse = 0.15 + Math.sin(t * 2 + node.x * 0.01) * 0.1;
        vtctx.beginPath();
        vtctx.moveTo(levels[0][0].x, levels[0][0].y);
        vtctx.lineTo(node.x, node.y);
        vtctx.strokeStyle = `rgba(123, 97, 255, ${pulse})`;
        vtctx.stroke();
      });
      levels[2].forEach((node, i) => {
        const parentIdx = i < 2 ? 0 : 1;
        const pulse = 0.15 + Math.sin(t * 2 + i * 0.8) * 0.1;
        vtctx.beginPath();
        vtctx.moveTo(levels[1][parentIdx].x, levels[1][parentIdx].y);
        vtctx.lineTo(node.x, node.y);
        vtctx.strokeStyle = `rgba(0, 255, 136, ${pulse})`;
        vtctx.stroke();
      });

      let nodeIdx = 0;
      levels.forEach((level) => {
        level.forEach((node) => {
          const breathe = 1 + Math.sin(t * 1.5 + nodeIdx * 0.9) * 0.15;
          const r = node.r * breathe;

          const glow = vtctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, r * 3);
          const hex = node.color;
          const cr = parseInt(hex.slice(1, 3), 16);
          const cg = parseInt(hex.slice(3, 5), 16);
          const cb = parseInt(hex.slice(5, 7), 16);
          glow.addColorStop(0, `rgba(${cr}, ${cg}, ${cb}, 0.25)`);
          glow.addColorStop(1, `rgba(${cr}, ${cg}, ${cb}, 0)`);
          vtctx.beginPath();
          vtctx.arc(node.x, node.y, r * 3, 0, Math.PI * 2);
          vtctx.fillStyle = glow;
          vtctx.fill();

          vtctx.beginPath();
          vtctx.arc(node.x, node.y, r, 0, Math.PI * 2);
          vtctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, 0.6)`;
          vtctx.shadowColor = node.color;
          vtctx.shadowBlur = 10;
          vtctx.fill();
          vtctx.shadowBlur = 0;

          nodeIdx++;
        });
      });

      for (let i = 0; i < 4; i++) {
        const parentIdx = i < 2 ? 0 : 1;
        const packetT = ((t * 0.8 + i * 0.5) % 2) / 2;
        if (packetT <= 1) {
          const fromNode = levels[1][parentIdx];
          const toNode = levels[2][i];
          const px = fromNode.x + (toNode.x - fromNode.x) * packetT;
          const py = fromNode.y + (toNode.y - fromNode.y) * packetT;
          vtctx.beginPath();
          vtctx.arc(px, py, 2.5, 0, Math.PI * 2);
          vtctx.fillStyle = `rgba(0, 255, 136, ${0.6 + Math.sin(t * 3 + i) * 0.3})`;
          vtctx.fill();
        }
      }

      requestAnimationFrame(drawVantalyze);
    }
    drawVantalyze();
  }

  // ─── First Draft Feed Canvas ─────────────────────
  const fdfCanvas = document.getElementById('fdf-canvas') as HTMLCanvasElement | null;
  if (fdfCanvas) {
    const fctx = fdfCanvas.getContext('2d')!;

    function resizeFdfCanvas() {
      const rect = fdfCanvas!.parentElement!.getBoundingClientRect();
      fdfCanvas!.width = rect.width || 400;
      fdfCanvas!.height = rect.height || 320;
    }
    resizeFdfCanvas();
    window.addEventListener('resize', resizeFdfCanvas);

    function drawFdf() {
      const w = fdfCanvas!.width;
      const h = fdfCanvas!.height;
      const t = Date.now() * 0.001;

      fctx.clearRect(0, 0, w, h);

      const cardCount = 5;
      const cardWidth = w * 0.55;
      const cardHeight = h * 0.12;
      const startY = h * 0.1;
      const gap = cardHeight + 12;
      const cx = w / 2;

      const lineX = cx - cardWidth / 2 - 15;
      fctx.beginPath();
      fctx.moveTo(lineX, startY);
      fctx.lineTo(lineX, startY + (cardCount - 1) * gap + cardHeight);
      const linePulse = 0.2 + Math.sin(t * 1.5) * 0.1;
      fctx.strokeStyle = `rgba(0, 212, 255, ${linePulse})`;
      fctx.lineWidth = 2;
      fctx.stroke();

      for (let i = 0; i < cardCount; i++) {
        const y = startY + i * gap;
        const cardAlpha = 0.08 + Math.sin(t * 1.2 + i * 0.7) * 0.04;
        const dotPulse = 0.5 + Math.sin(t * 2 + i * 1.1) * 0.3;

        fctx.beginPath();
        fctx.arc(lineX, y + cardHeight / 2, 4, 0, Math.PI * 2);
        fctx.fillStyle = `rgba(0, 212, 255, ${dotPulse})`;
        fctx.shadowColor = '#00d4ff';
        fctx.shadowBlur = 8;
        fctx.fill();
        fctx.shadowBlur = 0;

        const cardX = cx - cardWidth / 2;
        fctx.fillStyle = `rgba(255, 255, 255, ${cardAlpha})`;
        fctx.beginPath();
        fctx.roundRect(cardX, y, cardWidth, cardHeight, 4);
        fctx.fill();

        const lineY = y + cardHeight * 0.35;
        const lineCount = 3;
        for (let j = 0; j < lineCount; j++) {
          const lx = cardX + 12;
          const ly = lineY + j * (cardHeight * 0.18);
          const lineWidth = cardWidth * (0.3 + Math.sin(t * 0.5 + i * 2 + j) * 0.15);
          const isAddition = (i + j) % 3 !== 0;
          const color = isAddition
            ? `rgba(0, 255, 136, ${0.3 + Math.sin(t + i + j) * 0.15})`
            : `rgba(255, 80, 80, ${0.25 + Math.sin(t + i + j) * 0.1})`;
          fctx.fillStyle = color;
          fctx.fillRect(lx, ly, lineWidth, 2);
        }
      }

      for (let i = 0; i < 3; i++) {
        const bx = cx + cardWidth / 2 + 10 + Math.sin(t * 0.8 + i * 2) * 8;
        const by = startY + (i * 2 + 0.5) * gap;
        const bAlpha = 0.3 + Math.sin(t * 1.5 + i * 1.3) * 0.15;
        fctx.fillStyle = `rgba(0, 255, 136, ${bAlpha})`;
        fctx.font = '600 9px "Space Mono", monospace';
        fctx.fillText(`+${Math.floor(80 + Math.sin(t * 0.3 + i) * 50)}w`, bx, by);
      }

      requestAnimationFrame(drawFdf);
    }
    drawFdf();
  }
</script>
